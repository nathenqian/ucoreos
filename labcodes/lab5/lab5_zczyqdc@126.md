#操作系统第五次实验报告
钱迪晨 2013011402 计35
##练习1
###题目1
请在实验报告中简要说明你的设计实现过程。

请在实验报告中描述当创建一个用户态进程并加载了应用程序后，CPU是如何让这个应用程序最终在用户态执行起来的。即这个用户态进程被ucore选择占用CPU执行（RUNNING态）到具体执行应用程序第一条指令的整个经过。

答：

实现过程就是两个初始化。

	proc->wait_state = 0;
	proc->cptr = proc->optr = proc->yptr = NULL;

CPU使用了int，exec指令加载了应用程序，然后使用wait等待用户进程运行，里面使用了schedule交换了控制权限。

###题目2
本次作业完成了challenge，带swap机制的cow。
具体实现方法。

在copyrange的时候，如果发现当前页表可写，则

* 将其设置不可写
* 将其设置不可换出
* 子进程进拷贝页表

在缺页的时候，进行判断：

* 写出错，vma可以写，但是页表不可写。这个时候进行拷贝。
* 页不存在，则换入，如果是写出错且vma可以写，这个时候进行拷贝。

由于保证了共享的页面不会被换出，这样swap的问题就解决的。（不然的话页面换出的时候，可能一个页表更新了，但是子进程的页表没有更新）

具体输出可以看cow分支下result文件。

由于lab5自身的一些问题，cow机制在这里还有缺陷。比如mm_create的时候会把所有的swap页清空，这也是因为lab5的时候，管理中只考虑了la不考虑mm的问题。

但是至少它可以工作了！并且是对的！

###题目3
请在实验报告中简要说明你对 fork/exec/wait/exit函数的分析。并回答如下问题：
 - 请分析fork/exec/wait/exit在实现中是如何影响进程的执行状态的？
 - 请给出ucore中一个用户态进程的执行状态生命周期图（包执行状态，执行状态之间的变换关系，以及产生变换的事件或函数调用）。（字符方式画即可）

答：

fork没有影响父进程，将子进程设置为可运行的。

exec只是将当前进程的memory更换了，也没有修改执行状态。

wait将当前进程设置成等待，然后进行schedule。

exit中，如果有父进程在等待当前进程，则唤醒父进程。如果孩子中有还在运行的，则过继给init。

(WAITTING fork/exec) -> (RUNNING schedule) -> (ZOMBIE 结束) -> (END)
(RUNNING schedule) -> (WAITTING do_wait) -> (RUNNING do_exit中唤醒)

##重要知识点
进程的切换。